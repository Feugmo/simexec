import os
from pathlib import Path
from pprint import pprint

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import psycopg2.extras
from aiida.common.extendeddicts import AttributeDict
from aiida.engine import run_get_node, submit
from aiida.orm import Code, Dict, StructureData
from aiida.plugins import CalculationFactory
from aiida_lammps.data.potential import EmpiricalPotential
from ase.build import bulk
from clusterx.parent_lattice import ParentLattice
from clusterx.structures_set import StructuresSet
from clusterx.super_cell import SuperCell
from psycopg2 import sql
from pymatgen.core import Lattice, Molecule, Structure
from pymatgen.ext.matproj import MPRester
from tqdm.notebook import tqdm


def get_DFT_ene(api_key, Element):
    """
    Input:
    api_key: The API Key Generated By MP
    Element: The element you want search for such as "Mg-Al" wil return the alloy contain Mg and Al

    Output
    The data collected will be the name of the alloy, MP-ID and according energy
    The fucntion will return a dictionary contains those information
    """
    with MPRester(api_key) as mpr:
        docs = mpr.get_entries(chemsys_formula_id_criteria=Element)
    name = []
    """al=[]
    mg=[]"""
    ene = []
    id = []
    final = {}
    for i in docs:
        name.append(str(i.composition))
        ene.append(i.energy)
        """
        atoms=str(i.composition).split("Mg")[1].split("Al")
        al.append(atoms[1])
        mg.append(atoms[0])"""
        id.append(i.entry_id)
        final = {}
    final["name"] = name
    final["MP ID"] = id
    final["energy"] = ene
    return final


def get_structure_data(api_key, id):
    """
    Input:
    api_key: The API Key Generated By MP
    id: list like object such as ["mp-1234"], if input as string will be turned into list, suggest to get from get_DFT_ene(api_key,Element)['MP ID']

    Output:
    information collected:
    sites (contains position information and element name)
    matrix (cells)
    a,b,c, cells parameter
    Volume
    The function will return a dictonary contain those information
    """
    if type(id) != list:
        id = list(id)
    matrix = []
    ass = []
    bs = []
    cs = []
    vs = []
    sites = []
    for i in id:
        with MPRester(api_key) as m:
            # Structure for material id
            structure = m.get_structure_by_material_id(i)
            result = structure.as_dict()["lattice"]
            sites.append(structure.as_dict()["sites"])
            matrix.append(result["matrix"])
            ass.append(result["a"])
            bs.append(result["b"])
            cs.append(result["c"])
            vs.append(result["volume"])
    final = {}
    final["MP ID"] = id
    final["A"] = ass
    final["B"] = bs
    final["C"] = cs
    final["Matrix"] = matrix
    final["Volume"] = vs
    final["Sites"] = sites
    return final


def lammps_calculations_v1(sites, matrix, codename):
    results = []
    """
    Input:
    sites: recommend using the sites value generated by get_structure_data: get_structure_data(api_key,id)["sites"]
    matrix recommend using the matrix value generated by get_structure_data:  get_structure_data(api_key,id)["matrix"]
    codename: The aiida code name used such as:"Lammps-optmize@localhost"

    Output:
    Dictionary of result recommend using extract_db to get the final energy
    """
    for k in range(len(sites)):
        posi = []
        ele = []
        for j in sites[k]:
            ele.append(j["species"][0]["element"])
            posi.append(j["xyz"])

        symbols = ele
        positions = posi
        cell = matrix[k]
        structure = StructureData(cell=cell)

        for i, position in enumerate(positions):
            structure.append_atom(position=position, symbols=symbols[i])

        structure.store()

        with open("almg.liu.eam.alloy") as handle:
            eam_data = {"type": "alloy", "file_contents": handle.readlines()}

        potential = {"pair_style": "eam", "data": eam_data}

        # lammps_machine = {"num_machines": 1, "parallel_env": "mpi*", "tot_num_mpiprocs": 16}

        parameters_opt = {
            "units": "metal",
            "relax": {
                "type": "tri",  # iso/aniso/tri
                "pressure": 0.0,  # bars
                "vmax": 0.000001,  # Angstrom^3
            },
            "minimize": {
                "style": "cg",
                "energy_tolerance": 1.0e-25,  # eV
                "force_tolerance": 1.0e-25,  # eV angstrom
                "max_evaluations": 100000,
                "max_iterations": 50000,
            },
        }

        LammpsOptimizeCalculation = CalculationFactory("lammps.optimize")
        inputs = LammpsOptimizeCalculation.get_builder()

        # Computer options
        options = AttributeDict()
        options.account = ""
        options.qos = ""
        options.resources = {
            "num_machines": 1,
            "num_mpiprocs_per_machine": 1,
            "tot_num_mpiprocs": 1,
        }
        # options.queue_name = 'iqtc04.q'
        options.max_wallclock_seconds = 3600
        inputs.metadata.options = options

        # Setup code
        inputs.code = Code.get_from_string(codename)

        # setup nodes
        inputs.structure = structure
        inputs.potential = EmpiricalPotential(type=potential["pair_style"], data=potential["data"])
        inputs.parameters = Dict(dict=parameters_opt)

        # run calculation
        result, node = run_get_node(LammpsOptimizeCalculation, **inputs)
        print("results:", result)

        # submit to deamon
        submit(LammpsOptimizeCalculation, **inputs)
        results.append(result)

    return results


def lammps_calculations_v2(positions, elements, matrix, codename):
    """
    This version only process one calculation at a time compare to v1, you need to
    put this into a for loop to get full result
    all the input are shape to fit for single input
    Input:
    positions: list for sites positions
    elements: lists for according elements
    codename: The aiida code name used such as:"Lammps-optmize@localhost"

    Output:
    Dictionary of result recommend using extract_db to get the final energy
    """

    symbols = elements
    positions = positions
    cell = matrix
    structure = StructureData(cell=cell)

    for i, position in enumerate(positions):
        structure.append_atom(position=position, symbols=symbols[i])

    structure.store()

    with open("almg.liu.eam.alloy") as handle:
        eam_data = {"type": "alloy", "file_contents": handle.readlines()}

    potential = {"pair_style": "eam", "data": eam_data}

    # lammps_machine = {"num_machines": 1, "parallel_env": "mpi*", "tot_num_mpiprocs": 16}

    parameters_opt = {
        "units": "metal",
        "relax": {
            "type": "tri",  # iso/aniso/tri
            "pressure": 0.0,  # bars
            "vmax": 0.000001,  # Angstrom^3
        },
        "minimize": {
            "style": "cg",
            "energy_tolerance": 1.0e-25,  # eV
            "force_tolerance": 1.0e-25,  # eV angstrom
            "max_evaluations": 100000,
            "max_iterations": 50000,
        },
    }

    LammpsOptimizeCalculation = CalculationFactory("lammps.optimize")
    inputs = LammpsOptimizeCalculation.get_builder()

    # Computer options
    options = AttributeDict()
    options.account = ""
    options.qos = ""
    options.resources = {
        "num_machines": 1,
        "num_mpiprocs_per_machine": 1,
        "tot_num_mpiprocs": 1,
    }
    # options.queue_name = 'iqtc04.q'
    options.max_wallclock_seconds = 3600
    inputs.metadata.options = options

    # Setup code
    inputs.code = Code.get_from_string(codename)

    # setup nodes
    inputs.structure = structure
    inputs.potential = EmpiricalPotential(type=potential["pair_style"], data=potential["data"])
    inputs.parameters = Dict(dict=parameters_opt)

    # run calculation
    result, node = run_get_node(LammpsOptimizeCalculation, **inputs)
    print("results:", result)

    # submit to deamon
    submit(LammpsOptimizeCalculation, **inputs)

    return result


def extract_db(result, database_name, user, port, pass_word):
    """
    Input:
    Result comes from lammps
    example:
    results: {'trajectory_data': <LammpsTrajectory: uuid: 7d993533-ddaa-4f14-9db4-89beef0844ba (pk: 248)>, 'structure': <StructureData: uuid: b84bbedf-100b-4a86-8a40-e57b72acd4b2 (pk: 249)>, 'results': <Dict: uuid: 6745f357-1079-4549-9c60-7221e749f559 (pk: 250)>, 'remote_folder': <RemoteData: uuid: 918a914e-e513-403a-89d8-db9b02343373 (pk: 246)>, 'retrieved': <FolderData: uuid: 446f023f-fab5-4c5c-a45d-aa2f4aae469a (pk: 247)>}
    node: uuid: 770b87bc-a782-4a47-8e67-8c390e2fdeaa (pk: 245) (aiida.calculations:lammps.optimize)
    database_name: The name of your database
    user: User name for database
    port: port access to database
    pass_word: user password

    Output:
    The output will be the energy calculated float
    """
    uuid = result["results"].uuid
    dbn = database_name
    user = user
    port = port
    pw = pass_word
    conn = psycopg2.connect(dbname=dbn, user=user, password=pw, host="127.0.0.1", port=port)
    cur = conn.cursor()
    cur.execute(
        """
    SELECT attributes FROM db_dbnode
    WHERE uuid='{}'

    """.format(
            uuid
        )
    )
    ene = cur.fetchall()
    cur.close()
    conn.close()
    return ene[0][0]["energy"]


def plot_convex_hull(name, energy, element):
    element_percents = []
    for i in name:
        i = str(i)
        ele1 = element.split("-")[0]
        ele2 = element.split("-")[1]
        elenum1 = int(i.split(ele1)[1].split(ele2)[0])
        elenum2 = int(i.split(ele1)[1].split(ele2)[1])
        ele_total = elenum1 + elenum2
        ele1_percent = elenum1 / ele_total * 100
        element_percents.append(ele1_percent)
    plt.figure(figsize=(10, 6))
    plt.scatter(element_percents, energy)
    plt.xlabel(f"{ele1}%", fontsize=16)
    plt.xticks(np.arange(0, 110, 10))
    plt.ylabel("Energy", fontsize=16)
    plt.title("Convex Hull", fontsize=20)
    plt.savefig(f"Convex_Hull_{element}.png")
